<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bihar Assembly Constituencies — SVG Viewer</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, Arial, sans-serif; }
    #controls { padding: 10px 12px; display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    #mapwrap { height: calc(100vh - 70px); }
    #status { color: #b00; margin-left: 8px; }
    svg { width: 100%; height: 100%; background: #f9fafb; display:block; }
    .ac { stroke: #1f77b4; stroke-width: 0.5; }
    .ac:hover { fill: #a9d0ff; cursor: pointer; }
    .selected { fill: #f7c6c6; stroke: #d62728; stroke-width: 1.2; }
    #info { font-size: 0.95rem; }
    
    .label { font: 12px/1.1 sans-serif; fill: #111; paint-order: stroke; stroke: #fff; stroke-width: 3px; stroke-linejoin: round; }
  </style>
</head>
<body>
  <div id="controls">
    <div style="display: flex; align-items: center; margin-bottom: 10px;">
      <strong style="margin-right: 15px;">Bihar Assembly (SVG)</strong>
      <span id="status" style="color: #b00;"></span>
    </div>
    <div style="position: relative; width: 100%; margin-bottom: 10px;">
      <input id="acSearch" type="search" placeholder="Search constituency by number, name, or district..."
             style="width: 100%; padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px;" />
      <div id="dropdown" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ccc; border-top: none; border-radius: 0 0 4px 4px; max-height: 300px; overflow-y: auto; display: none; z-index: 1000; box-shadow: 0 2px 8px rgba(0,0,0,0.15);"></div>
    </div>
    <div style="margin-bottom: 10px;">
      <label for="colorMode" style="margin-right: 8px; font-weight: 500;">Color by:</label>
      <select id="colorMode" style="padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px;">
        <option value="alliance-2020" selected>2020 Alliance (Current)</option>
        <option value="party-2020">2020 Party</option>
        <option value="reserved">Reserved Status</option>
        <option value="alliance-2015">2015 Alliance</option>
        <option value="party-2015">2015 Party</option>
        <option value="alliance-2010">2010 Alliance</option>
        <option value="party-2010">2010 Party</option>
      </select>
    </div>
    <div id="info"></div>
    <div id="legend" style="margin-top: 5px; font-size: 13px; display: none;"></div>
  </div>
  <div id="mapwrap" class="loading">
    <svg id="svg" viewBox="0 0 1200 900" preserveAspectRatio="xMidYMid meet">
      <g id="zoomlayer"></g>
      <g id="uiLayer"></g>
    </svg>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script>
    const width = 1200, height = 900;
    const svg = d3.select('#svg');
    const g = d3.select('#zoomlayer');
    const ui = d3.select('#uiLayer');
    const labelLayer = g.append('g').attr('id','labelLayer');
    const statusEl = document.getElementById('status');
    const infoEl = document.getElementById('info');
    const searchEl = document.getElementById('acSearch');
    const dropdownEl = document.getElementById('dropdown');
    const wrapEl = document.getElementById('mapwrap');
    const colorModeEl = document.getElementById('colorMode');
    const legendEl = document.getElementById('legend');
    let searchData = [];
    let labelToKey = new Map();
    let electionData = new Map();
    let partyColors = new Map();
    let allianceColors = new Map();
    let partyToAlliance = new Map();
    let partyData = new Map(); // Store complete party information
    let currentColorMode = 'alliance-2020';

    let biharData = null;
    let projection, path;
    let selectedId = null;

    // Color utilities
    function pastelizeColor(hex, mix = 0.25) {
      if (!hex || typeof hex !== 'string') return '#e5e7eb';
      const normalized = hex.replace('#', '').trim();
      if (!normalized || normalized.length !== 6 || /[^0-9a-f]/i.test(normalized)) return '#e5e7eb';

      const r = parseInt(normalized.slice(0, 2), 16);
      const g = parseInt(normalized.slice(2, 4), 16);
      const b = parseInt(normalized.slice(4, 6), 16);

      const blend = (component) => Math.round(component + (255 - component) * mix);
      const toHex = (value) => value.toString(16).padStart(2, '0');

      return '#' + toHex(blend(r)) + toHex(blend(g)) + toHex(blend(b));
    }

    function getColorForMode(acNo, mode) {
      const row = electionData.get(acNo);
      if (!row) return '#f3f4f6'; // Light gray for missing data

      switch(mode) {
        case 'alliance-2020':
          return allianceColors.get(row.current_mla_alliance) || '#f3f4f6';
        case 'party-2020':
          return partyColors.get(row.current_mla_party) || allianceColors.get(row.current_mla_alliance) || '#f3f4f6';
        case 'reserved':
          const status = row.reserved || 'GEN';
          const reservedColors = { 'GEN': '#f9fafb', 'SC': '#dbeafe', 'ST': '#dcfce7', 'NA': '#f3f4f6' };
          return reservedColors[status] || reservedColors['GEN'];
        case 'alliance-2015':
          return getHistoricalAllianceColor(row.y2015_winner_party, '2015');
        case 'party-2015':
          return partyColors.get(row.y2015_winner_party) || getHistoricalAllianceColor(row.y2015_winner_party, '2015');
        case 'alliance-2010':
          return getHistoricalAllianceColor(row.y2010_winner_party, '2010');
        case 'party-2010':
          return partyColors.get(row.y2010_winner_party) || getHistoricalAllianceColor(row.y2010_winner_party, '2010');
        default:
          return '#f3f4f6';
      }
    }

    function getHistoricalAllianceColor(party, year) {
      if (!party) return '#f3f4f6';

      const party_info = partyData.get(party);
      if (!party_info) return '#f3f4f6';

      let alliance;
      if (year === '2015') {
        alliance = party_info.alliance_2015;
      } else if (year === '2010') {
        alliance = party_info.alliance_2010;
      } else {
        alliance = party_info.alliance_2020;
      }

      // Map special alliance codes to our main color categories
      if (alliance === 'RJD+') alliance = 'MGB'; // RJD+ mapped to MGB colors
      if (alliance === 'UPA') alliance = 'OTH';  // UPA mapped to Others
      if (alliance === 'LF') alliance = 'OTH';   // Left Front mapped to Others
      if (alliance === 'SSM') alliance = 'OTH';  // Socialist Secular Morcha mapped to Others
      if (alliance === 'NA') return '#e5e7eb';   // Independent - return directly

      return allianceColors.get(alliance) || '#f3f4f6';
    }

    function getPartyAlliance(party) {
      return partyToAlliance.get(party) || 'NA';
    }

    // Proper CSV parsing function to handle quoted values and commas
    function parseCSVLine(line) {
      const result = [];
      let current = '';
      let inQuotes = false;

      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        const nextChar = line[i + 1];

        if (char === '"') {
          if (inQuotes && nextChar === '"') {
            // Escaped quote within quoted field
            current += '"';
            i++; // Skip the next quote
          } else {
            // Toggle quote state
            inQuotes = !inQuotes;
          }
        } else if (char === ',' && !inQuotes) {
          // Field separator outside of quotes
          result.push(current.trim());
          current = '';
        } else {
          current += char;
        }
      }

      // Add the last field
      result.push(current.trim());
      return result;
    }

    const zoom = d3.zoom().scaleExtent([1, 20]).on('zoom', (ev) => {
      g.attr('transform', ev.transform);
      updateCrossButton();
    });
    svg.call(zoom);

    function setInfo(html){ infoEl.innerHTML = html || ''; }

    function createSvgControls(){
      // Cross button (top-right)
      const crossButton = ui.append('g')
        .attr('class', 'cross-button')
        .attr('transform', `translate(${width - 30}, 30)`)
        .style('cursor', 'pointer')
        .style('display', 'none');

      crossButton.append('circle')
        .attr('r', 15)
        .attr('fill', 'white')
        .attr('stroke', '#666')
        .attr('stroke-width', 1);

      crossButton.append('path')
        .attr('d', 'M-6,-6 L6,6 M6,-6 L-6,6')
        .attr('stroke', '#333')
        .attr('stroke-width', 2);

      crossButton.on('click', clearAndReset);

      // Zoom In button (top-right, below cross)
      const zoomInButton = ui.append('g')
        .attr('class', 'zoom-in-button')
        .attr('transform', `translate(${width - 30}, 70)`)
        .style('cursor', 'pointer');

      zoomInButton.append('circle')
        .attr('r', 15)
        .attr('fill', 'white')
        .attr('stroke', '#666')
        .attr('stroke-width', 1);

      zoomInButton.append('text')
        .attr('text-anchor', 'middle')
        .attr('dy', '0.35em')
        .attr('font-size', '14px')
        .attr('font-weight', 'bold')
        .text('+');

      zoomInButton.on('click', () => svg.transition().duration(300).call(zoom.scaleBy, 1.3));

      // Zoom Out button (top-right, below zoom in)
      const zoomOutButton = ui.append('g')
        .attr('class', 'zoom-out-button')
        .attr('transform', `translate(${width - 30}, 110)`)
        .style('cursor', 'pointer');

      zoomOutButton.append('circle')
        .attr('r', 15)
        .attr('fill', 'white')
        .attr('stroke', '#666')
        .attr('stroke-width', 1);

      zoomOutButton.append('text')
        .attr('text-anchor', 'middle')
        .attr('dy', '0.35em')
        .attr('font-size', '16px')
        .attr('font-weight', 'bold')
        .text('−');

      zoomOutButton.on('click', () => svg.transition().duration(300).call(zoom.scaleBy, 1/1.3));
    }

    function updateCrossButton(){
      const transform = d3.zoomTransform(svg.node());
      const isZoomed = transform.k > 1.01;
      const isSelected = selectedId !== null;

      ui.select('.cross-button')
        .style('display', (isZoomed || isSelected) ? 'block' : 'none');
    }

    function featureKey(p){
      const n = p.AC_NO ?? p.ac_no ?? p.Ac_No;
      try { return String(parseInt(+n)).padStart(3,'0'); } catch { return String(n||''); }
    }

    function populateSearch(features){
      searchData = features.map(f => ({
        key: featureKey(f.properties),
        name: f.properties.AC_NAME || f.properties.ac_name || f.properties.Ac_Name || 'AC',
        dist: f.properties.DIST_NAME || f.properties.dist_name || ''
      })).sort((a,b) => a.key.localeCompare(b.key));

      // Create searchable labels
      searchData.forEach(item => {
        const label = `${item.key} - ${item.name}${item.dist? ' ('+item.dist+')':''}`;
        labelToKey.set(label, item.key);
        item.label = label;
        item.searchText = `${item.key} ${item.name} ${item.dist}`.toLowerCase();
      });
    }

    function showDropdown(matches) {
      if (matches.length === 0) {
        dropdownEl.style.display = 'none';
        return;
      }

      dropdownEl.innerHTML = '';

      // Show more results for full list, fewer for search results
      const isFullList = matches.length === searchData.length;
      const limit = isFullList ? 50 : 15;

      matches.slice(0, limit).forEach((item, index) => {
        const div = document.createElement('div');
        div.textContent = item.label;
        div.style.cssText = 'padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 14px;';
        div.addEventListener('mouseenter', () => {
          div.style.backgroundColor = '#f0f0f0';
        });
        div.addEventListener('mouseleave', () => {
          div.style.backgroundColor = '';
        });
        div.addEventListener('click', () => {
          searchEl.value = item.label;
          selectByKey(item.key);
          dropdownEl.style.display = 'none';
        });
        dropdownEl.appendChild(div);
      });

      // Add "showing X of Y" indicator if there are more results
      if (matches.length > limit) {
        const moreDiv = document.createElement('div');
        moreDiv.textContent = `Showing ${limit} of ${matches.length} constituencies...`;
        moreDiv.style.cssText = 'padding: 8px 12px; color: #666; font-style: italic; background: #f9f9f9; font-size: 12px;';
        dropdownEl.appendChild(moreDiv);
      }

      dropdownEl.style.display = 'block';
    }

    function hideDropdown() {
      setTimeout(() => dropdownEl.style.display = 'none', 150);
    }

    function draw(features){
      g.selectAll('path').data(features)
        .join('path')
        .attr('class', 'ac')
        .attr('data-key', d => featureKey(d.properties))
        .attr('d', d => path(d))
        .attr('fill', d => getColorForMode(featureKey(d.properties), currentColorMode))
        .on('click', (ev, d) => selectByKey(featureKey(d.properties)));
    }

    function fitToFeature(f){
      const b = path.bounds(f);
      const dx = b[1][0] - b[0][0];
      const dy = b[1][1] - b[0][1];
      const cx = (b[0][0] + b[1][0]) / 2;
      const cy = (b[0][1] + b[1][1]) / 2;
      const scale = Math.max(1, 0.9 / Math.max(dx / width, dy / height));
      const transform = d3.zoomIdentity.translate(width/2, height/2).scale(scale).translate(-cx, -cy);
      svg.transition().duration(750).call(zoom.transform, transform);
    }

    function clearAndReset(){
      selectedId = null;
      g.selectAll('path').classed('selected', false);
      searchEl.value = '';
      setInfo('');
      labelLayer.selectAll('*').remove();
      // Reset zoom
      svg.transition().duration(400).call(zoom.transform, d3.zoomIdentity);
      updateCrossButton();
    }

    function selectByKey(key){
      selectedId = key;
      g.selectAll('path').classed('selected', d => featureKey(d.properties) === key);
      g.selectAll('path').filter(d => featureKey(d.properties) === key).raise();
      const f = biharData.features.find(ft => featureKey(ft.properties) === key);
      if(f){
        fitToFeature(f);
        const p = f.properties;
        const acno = key;
        const acname = p.AC_NAME || p.ac_name || p.Ac_Name || '';
        const dist = p.DIST_NAME || p.dist_name || '';
        const pcno = p.PC_NO || p.pc_no || '';
        const pcname = p.PC_NAME || p.pc_name || '';

        // Update search bar with selected constituency
        const searchLabel = `${acno} - ${acname}${dist? ' ('+dist+')':''}`;
        searchEl.value = searchLabel;

        setInfo(`<b>${acno} ${acname}</b>${dist? ' · District: '+dist:''}${pcname? ' · PC: '+pcno+' '+pcname:''}`);

        // Console log detailed constituency information
        const electionInfo = electionData.get(acno);
        console.log('=== CONSTITUENCY SELECTED ===');
        console.log('AC Number:', acno);
        console.log('AC Name:', acname);
        console.log('District:', dist);
        console.log('PC Number:', pcno);
        console.log('PC Name:', pcname);

        if (electionInfo) {
          console.log('\n--- 2020 ELECTION DATA ---');
          console.log('Current MLA:', electionInfo.current_mla_name);
          console.log('Current Party:', electionInfo.current_mla_party);
          console.log('Current Alliance:', electionInfo.current_mla_alliance);
          console.log('Reserved Status:', electionInfo.reserved || 'GEN');

          console.log('\n--- HISTORICAL WINNERS ---');
          if (electionInfo.y2020_winner_name) {
            console.log('2020 Winner:', electionInfo.y2020_winner_name, '(' + electionInfo.y2020_winner_party + ')');
            console.log('2020 Votes:', electionInfo.y2020_winner_votes, 'Margin:', electionInfo.y2020_margin);
          }
          if (electionInfo.y2015_winner_name) {
            console.log('2015 Winner:', electionInfo.y2015_winner_name, '(' + electionInfo.y2015_winner_party + ')');
            console.log('2015 Votes:', electionInfo.y2015_winner_votes, 'Margin:', electionInfo.y2015_margin);
          }
          if (electionInfo.y2010_winner_name) {
            console.log('2010 Winner:', electionInfo.y2010_winner_name, '(' + electionInfo.y2010_winner_party + ')');
            console.log('2010 Votes:', electionInfo.y2010_winner_votes, 'Margin:', electionInfo.y2010_margin);
          }

          console.log('\n--- CHANGES FROM 2020 ---');
          console.log('Different Party vs 2020:', electionInfo.diff_party_vs_2020 === 'True' ? 'Yes' : 'No');
          console.log('Different Name vs 2020:', electionInfo.diff_name_vs_2020 === 'True' ? 'Yes' : 'No');

          console.log('\n--- RAW DATA OBJECT ---');
          console.log(electionInfo);
        } else {
          console.log('\n⚠️ No election data found for this constituency');
        }
        console.log('==============================\n');

        // Add center label for selection
        try {
          const c = path.centroid(f);
          labelLayer.raise();
          labelLayer.selectAll('text.sel')
            .data([f])
            .join('text')
            .attr('class','label sel')
            .attr('x', c[0])
            .attr('y', c[1])
            .attr('text-anchor','middle')
            .text(acno + ' ' + acname);
        } catch(e) { console.error('label error', e); }
      }
      updateCrossButton();
    }

    // Search input event handlers
    searchEl.addEventListener('input', (e) => {
      const query = e.target.value.trim().toLowerCase();

      if (!query) {
        hideDropdown();
        return;
      }

      // Filter search data
      const matches = searchData.filter(item =>
        item.searchText.includes(query)
      );

      showDropdown(matches);
    });

    searchEl.addEventListener('change', () => {
      const value = searchEl.value.trim();
      const key = labelToKey.get(value);
      if(key){
        selectByKey(key);
        dropdownEl.style.display = 'none';
      } else if(!value) {
        clearAndReset();
        dropdownEl.style.display = 'none';
      }
    });

    searchEl.addEventListener('blur', hideDropdown);
    searchEl.addEventListener('focus', () => {
      // Show all constituencies if no search query, or filtered results if there is a query
      const query = searchEl.value.trim().toLowerCase();
      if (query) {
        const matches = searchData.filter(item => item.searchText.includes(query));
        showDropdown(matches);
      } else {
        // Show all constituencies when clicked with no search text
        showDropdown(searchData);
      }
    });

    searchEl.addEventListener('click', () => {
      // Also show full dropdown on click (in case focus doesn't trigger)
      if (!searchEl.value.trim()) {
        showDropdown(searchData);
      }
    });

    // Color mode change handler
    colorModeEl.addEventListener('change', () => {
      currentColorMode = colorModeEl.value;
      g.selectAll('path').attr('fill', d => getColorForMode(featureKey(d.properties), currentColorMode));
      updateLegend();
    });

    function updateLegend() {
      if (!electionData.size) {
        legendEl.style.display = 'none';
        return;
      }

      const mode = currentColorMode;
      let legendItems = [];

      if (mode.includes('alliance')) {
        legendItems = [
          { color: allianceColors.get('NDA'), label: 'NDA' },
          { color: allianceColors.get('MGB'), label: 'MGB' },
          { color: allianceColors.get('OTH'), label: 'Others' },
          { color: '#e5e7eb', label: 'Independent' }
        ];
      } else if (mode === 'reserved') {
        legendItems = [
          { color: '#f9fafb', label: 'General' },
          { color: '#dbeafe', label: 'SC Reserved' },
          { color: '#dcfce7', label: 'ST Reserved' },
          { color: '#f3f4f6', label: 'No Data' }
        ];
      } else if (mode.includes('party')) {
        // Show top parties only for party mode
        const partyCount = new Map();
        for (const [key, row] of electionData) {
          const party = mode === 'party-2020' ? row.current_mla_party :
                       mode === 'party-2015' ? row.y2015_winner_party :
                       mode === 'party-2010' ? row.y2010_winner_party : null;
          if (party) partyCount.set(party, (partyCount.get(party) || 0) + 1);
        }

        const topParties = Array.from(partyCount.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 6)
          .map(([party, count]) => ({
            color: partyColors.get(party) || '#f3f4f6',
            label: `${party} (${count})`
          }));

        legendItems = topParties;
      }

      legendEl.innerHTML = legendItems
        .map(item => `<span style="margin-right: 15px;"><span style="color: ${item.color}; font-size: 16px;">■</span> ${item.label}</span>`)
        .join('');

      legendEl.style.display = 'block';
    }




    async function loadElectionData() {
      try {
        // Load parties.csv
        const partiesResponse = await fetch('parties.csv');
        const partiesText = await partiesResponse.text();
        const partiesLines = partiesText.split('\n');
        const partiesHeaders = parseCSVLine(partiesLines[0]);

        // Set up alliance colors with more distinct colors
        allianceColors.set('NDA', pastelizeColor('#0066cc'));  // Blue
        allianceColors.set('MGB', pastelizeColor('#cc3300'));  // Red
        allianceColors.set('OTH', pastelizeColor('#8A2BE2'));  // Purple
        allianceColors.set('NA', '#e5e7eb');  // Light gray

        // Parse parties CSV
        for (let i = 1; i < partiesLines.length; i++) {
          const line = partiesLines[i].trim();
          if (!line) continue;

          const values = parseCSVLine(line);
          const party = {};
          partiesHeaders.forEach((header, index) => {
            party[header] = values[index] || '';
          });

          // Store in maps
          partyColors.set(party.code, pastelizeColor(party.color));
          partyToAlliance.set(party.code, party.alliance_2020); // Current alliance for general use
          partyData.set(party.code, party); // Full party data for historical lookups
        }

        // Load election results CSV with proper parsing
        const csvResponse = await fetch('bihar_election_results_consolidated.csv');
        const csvText = await csvResponse.text();
        const lines = csvText.split('\n');
        const headers = parseCSVLine(lines[0]);

        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;

          const values = parseCSVLine(line);
          const row = {};
          headers.forEach((header, index) => {
            row[header] = values[index] || '';
          });

          const acNo = String(parseInt(row.no || '0')).padStart(3, '0');
          electionData.set(acNo, row);
        }

        console.log(`Loaded ${electionData.size} constituency records`);
        return true;
      } catch (e) {
        console.error('Failed to load election data:', e);
        return false;
      }
    }

    async function init(){
      try{
        statusEl.textContent = 'Loading Bihar data...';

        // Load election data first
        const dataLoaded = await loadElectionData();

        // Load GeoJSON
        const geoData = await fetch('bihar_ac_all.geojson').then(r => r.json());
        biharData = geoData;
        projection = d3.geoMercator().fitSize([width, height], biharData);
        path = d3.geoPath(projection);

        draw(biharData.features);
        populateSearch(biharData.features);
        createSvgControls();

        if (dataLoaded) {
          // Update colors now that data is loaded
          g.selectAll('path').attr('fill', d => getColorForMode(featureKey(d.properties), currentColorMode));
          updateLegend();
        }

        wrapEl.classList.remove('loading');
        statusEl.textContent = '';
      }catch(e){
        console.error(e);
        statusEl.textContent = 'Failed to load Bihar data';
      }
    }

    init();
  </script>
</body>
</html>





